# -*- coding: utf-8 -*-
"""NLU - Lab8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oz-cUnnn0ehBF8PIX-bh_gJxya-OAey-


"""# Lab Exercise

## Import & Installing
"""

import nltk
nltk.download('averaged_perceptron_tagger')
nltk.download('senseval')
nltk.download('punkt')
nltk.download('wordnet')
nltk.download('universal_tagset')
from nltk.corpus import senseval
inst = senseval.instances('interest.pos')[0]
from sklearn.feature_extraction import DictVectorizer
from sklearn.model_selection import cross_validate
from sklearn.naive_bayes import MultinomialNB
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import StratifiedKFold
from nltk import ngrams
from sklearn.feature_extraction.text import CountVectorizer
import numpy as np
from nltk.corpus import wordnet
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
nltk.download('stopwords')
from nltk.metrics.scores import precision, recall, f_measure, accuracy
from collections import Counter
from tqdm import tqdm

"""## Extend Collocational Features with POS-Tags"""

def collocational_features(inst):
    p = inst.position
    return {
        "w-2_word": 'NULL' if p < 2 else inst.context[p-2][0],
        "w-2_pos": 'NULL' if p < 2 else inst.context[p-2][1],
        "w-1_word": 'NULL' if p < 1 else inst.context[p-1][0],
        "w-1_pos": 'NULL' if p < 1 else inst.context[p-1][1],
        "w+1_word": 'NULL' if len(inst.context) - 1 < p+1 else inst.context[p+1][0],
        "w+1_pos": 'NULL' if len(inst.context) - 1 < p+1 else inst.context[p+1][1],
        "w+2_word": 'NULL' if len(inst.context) - 1 < p+2 else inst.context[p+2][0],
        "w+2_pos": 'NULL' if len(inst.context) - 1 < p+2 else inst.context[p+2][1]
    }

data_col = [collocational_features(inst) for inst in senseval.instances('interest.pos')]
print(data_col[0])
lbls = [inst.senses[0] for inst in senseval.instances('interest.pos')]

dvectorizer = DictVectorizer(sparse=False)
dvectors = dvectorizer.fit_transform(data_col)
classifier = MultinomialNB()
lblencoder = LabelEncoder()

lblencoder.fit(lbls)
labels = lblencoder.transform(lbls)

stratified_split = StratifiedKFold(n_splits=5, shuffle=True)

scores = cross_validate(classifier, dvectors, labels, cv=stratified_split, scoring=['f1_micro'])

print("Extend with POS-Tags:")
print(sum(scores['test_f1_micro'])/len(scores['test_f1_micro']))

"""## Extend Collocational Features with Ngrams within window"""

def collocational_features(inst, n=2):
    context_words = [token[0] for token in inst.context]
    context_pos = [token[1] for token in inst.context]
    ngrams_within_window = list(ngrams(context_words, n))
    ngram_features = {}
    p = inst.position
    for i, ngram in enumerate(ngrams_within_window):
        feature_name = f"ngram_{i}"
        ngram_features[feature_name] = " ".join(ngram)
    features = {
        "w-2_word": 'NULL' if p < 2 else inst.context[p-2][0],
        "w-2_pos": 'NULL' if p < 2 else inst.context[p-2][1],
        "w-1_word": 'NULL' if p < 1 else inst.context[p-1][0],
        "w-1_pos": 'NULL' if p < 1 else inst.context[p-1][1],
        "w+1_word": 'NULL' if len(inst.context) - 1 < p+1 else inst.context[p+1][0],
        "w+1_pos": 'NULL' if len(inst.context) - 1 < p+1 else inst.context[p+1][1],
        "w+2_word": 'NULL' if len(inst.context) - 1 < p+2 else inst.context[p+2][0],
        "w+2_pos": 'NULL' if len(inst.context) - 1 < p+2 else inst.context[p+2][1]
    }
    features.update(ngram_features)
    return features

data_col = [collocational_features(inst) for inst in senseval.instances('interest.pos')]
print(data_col[0])
lbls = [inst.senses[0] for inst in senseval.instances('interest.pos')]

dvectorizer = DictVectorizer(sparse=False)
dvectors = dvectorizer.fit_transform(data_col)
classifier = MultinomialNB()
lblencoder = LabelEncoder()

lblencoder.fit(lbls)
labels = lblencoder.transform(lbls)

stratified_split = StratifiedKFold(n_splits=5, shuffle=True)

scores = cross_validate(classifier, dvectors, labels, cv=stratified_split, scoring=['f1_micro'])

print("Extend with N-grams:")
print(sum(scores['test_f1_micro'])/len(scores['test_f1_micro']))

"""## Concatenate BOW and evaluate"""

bow_data = [" ".join([t[0] for t in inst.context]) for inst in senseval.instances('interest.pos')]
bow_lbls = [inst.senses[0] for inst in senseval.instances('interest.pos')]

bow_vectorizer = CountVectorizer()
bow_classifier = MultinomialNB()
bow_lblencoder = LabelEncoder()

stratified_split = StratifiedKFold(n_splits=5, shuffle=True)

bow_vectors = bow_vectorizer.fit_transform(bow_data)

# encoding labels for multi-calss
bow_lblencoder.fit(bow_lbls)
bow_labels = lblencoder.transform(bow_lbls)

print(bow_vectors.shape, type(bow_vectors))
print(dvectors.shape, type(dvectors))

test_features = np.concatenate((bow_vectors.toarray(), dvectors), axis=1)

scores = cross_validate(classifier, test_features, labels, cv=stratified_split, scoring=['f1_micro'])

print("Concatenate BOW:")
print(sum(scores['test_f1_micro'])/len(scores['test_f1_micro']))

"""## Evaluate Lesk Original"""

def preprocess(text):
    mapping = {"NOUN": wordnet.NOUN, "VERB": wordnet.VERB, "ADJ": wordnet.ADJ, "ADV": wordnet.ADV}
    sw_list = stopwords.words('english')

    lem = WordNetLemmatizer()

    # tokenize, if input is text
    tokens = nltk.word_tokenize(text) if type(text) is str else text
    # pos-tag
    tagged = nltk.pos_tag(tokens, tagset="universal")
    # lowercase
    tagged = [(w.lower(), p) for w, p in tagged]
    # optional: remove all words that are not NOUN, VERB, ADJ, or ADV (i.e. no sense in WordNet)
    tagged = [(w, p) for w, p in tagged if p in mapping]
    # re-map tags to WordNet (return orignal if not in-mapping, if above is not used)
    tagged = [(w, mapping.get(p, p)) for w, p in tagged]
    # remove stopwords
    tagged = [(w, p) for w, p in tagged if w not in sw_list]
    # lemmatize
    tagged = [(w, lem.lemmatize(w, pos=p), p) for w, p in tagged]
    # unique the list
    tagged = list(set(tagged))
    return tagged



def original_lesk(context_sentence, ambiguous_word, pos=None, synsets=None, majority=False, features=None):

    context_senses = get_sense_definitions(set(context_sentence)-set([ambiguous_word]))
    if synsets is None:
        synsets = get_sense_definitions(ambiguous_word)[0][1]

    if pos:
        synsets = [ss for ss in synsets if str(ss[0].pos()) == pos]

    if not synsets:
        return None
    scores = []
    # print(synsets)
    for senses in context_senses:
        for sense in senses[1]:
            if features is not None:
                # Aggiungi le feature al contesto per il calcolo del punteggio
                score = get_top_sense(sense[1] + features.tolist(), synsets)
            else:
                score = get_top_sense(sense[1], synsets)
            scores.append(score)

    if len(scores) == 0:
        return synsets[0][0]

    if majority:
        filtered_scores = [x[1] for x in scores if x[0] != 0]
        if len(filtered_scores) > 0:
            best_sense = Counter(filtered_scores).most_common(1)[0][0]
        else:
            # Almost random selection
            best_sense = Counter([x[1] for x in scores]).most_common(1)[0][0]
    else:
        _, best_sense = max(scores)
    return best_sense


def get_sense_definitions(context):
    # input is text or list of strings
    lemma_tags = preprocess(context)
    # let's get senses for each
    senses = [(w, wordnet.synsets(l, p)) for w, l, p in lemma_tags]

    # let's get their definitions
    definitions = []
    for raw_word, sense_list in senses:
        if len(sense_list) > 0:
            # let's tokenize, lowercase & remove stop words
            def_list = []
            for s in sense_list:
                defn = s.definition()
                # let's use the same preprocessing
                tags = preprocess(defn)
                toks = [l for w, l, p in tags]
                def_list.append((s, toks))
            definitions.append((raw_word, def_list))
    return definitions


def get_top_sense(words, sense_list):
    # get top sense from the list of sense-definition tuples
    # assumes that words and definitions are preprocessed identically
    val, sense = max((len(set(words).intersection(set(defn))), ss) for ss, defn in sense_list)
    return val, sense

mapping = {
    'interest_1': 'interest.n.01',
    'interest_2': 'interest.n.03',
    'interest_3': 'pastime.n.01',
    'interest_4': 'sake.n.01',
    'interest_5': 'interest.n.05',
    'interest_6': 'interest.n.04',
}

refs = {k: set() for k in mapping.values()}
hyps = {k: set() for k in mapping.values()}
refs_list = []
hyps_list = []

synsets = []
for ss in tqdm(wordnet.synsets('interest', pos='n')):
    if ss.name() in mapping.values():
        defn = ss.definition()
        tags = preprocess(defn)
        toks = [l for w, l, p in tags]
        synsets.append((ss,toks))

for i, inst in tqdm(enumerate(senseval.instances('interest.pos'))):
    txt = [t[0] for t in inst.context]
    raw_ref = inst.senses[0] # let's get first sense

    test_instance_features = test_features[i]

    hyp = original_lesk(txt, txt[inst.position], synsets=synsets, majority=True, features=test_instance_features).name()
    ref = mapping.get(raw_ref)

    # for precision, recall, f-measure
    refs[ref].add(i)
    hyps[hyp].add(i)

    # for accuracy
    refs_list.append(ref)
    hyps_list.append(hyp)

print("Lesk original: ")
print("Acc:", round(accuracy(refs_list, hyps_list), 3))

for cls in hyps.keys():
    p = precision(refs[cls], hyps[cls])
    r = recall(refs[cls], hyps[cls])
    f = f_measure(refs[cls], hyps[cls], alpha=1)

    print("{:15s}: p={:.3f}; r={:.3f}; f={:.3f}; s={}".format(cls, p, r, f, len(refs[cls])))

"""## Evaluate Lesk Similarity"""

def lesk_similarity(context_sentence, ambiguous_word, similarity="resnik", pos=None,
                    synsets=None, majority=True):
    context_senses = get_sense_definitions(set(context_sentence) - set([ambiguous_word]))

    if synsets is None:
        synsets = get_sense_definitions(ambiguous_word)[0][1]

    if pos:
        synsets = [ss for ss in synsets if str(ss[0].pos()) == pos]

    if not synsets:
        return None

    scores = []

    # Here you may have some room for improvement
    # For instance instead of using all the definitions from the context
    # you pick the most common one of each word (i.e. the first)
    for senses in context_senses:
        for sense in senses[1]:
            scores.append(get_top_sense_sim(sense[0], synsets, similarity))

    if len(scores) == 0:
        return synsets[0][0]

    if majority:
        filtered_scores = [x[1] for x in scores if x[0] != 0]
        if len(filtered_scores) > 0:
            best_sense = Counter(filtered_scores).most_common(1)[0][0]
        else:
            # Almost random selection
            best_sense = Counter([x[1] for x in scores]).most_common(1)[0][0]
    else:
        _, best_sense = max(scores)

    return best_sense


#semcor_ic = wordnet_ic.ic('ic-semcor.dat')
def get_top_sense_sim(context_sense, sense_list, similarity):
    # get top sense from the list of sense-definition tuples
    # assumes that words and definitions are preprocessed identically
    scores = []
    for sense in sense_list:
        ss = sense[0]
        if similarity == "path":
            try:
                scores.append((context_sense.path_similarity(ss), ss))
            except:
                scores.append((0, ss))
        elif similarity == "lch":
            try:
                scores.append((context_sense.lch_similarity(ss), ss))
            except:
                scores.append((0, ss))
        elif similarity == "wup":
            try:
                scores.append((context_sense.wup_similarity(ss), ss))
            except:
                scores.append((0, ss))
        elif similarity == "resnik":
            try:
                scores.append((context_sense.res_similarity(ss, semcor_ic), ss))
            except:
                scores.append((0, ss))
        elif similarity == "lin":
            try:
                scores.append((context_sense.lin_similarity(ss, semcor_ic), ss))
            except:
                scores.append((0, ss))
        elif similarity == "jiang":
            try:
                scores.append((context_sense.jcn_similarity(ss, semcor_ic), ss))
            except:
                scores.append((0, ss))
        else:
            print("Similarity metric not found")
            return None
    val, sense = max(scores)
    return val, sense

sim_refs = {k: set() for k in mapping.values()}
sim_hyps = {k: set() for k in mapping.values()}
sim_refs_list = []
sim_hyps_list = []

sim_synsets = []
for ss in wordnet.synsets('interest', pos='n'):
    if ss.name() in mapping.values():
        defn = ss.definition()
        tags = preprocess(defn)
        toks = [l for w, l, p in tags]
        sim_synsets.append((ss,toks))

for i, inst in tqdm(enumerate(senseval.instances('interest.pos'))):
    txt = [t[0] for t in inst.context]
    raw_ref = inst.senses[0] # let's get first sense

    test_instance_features = test_features[i]

    hyp = lesk_similarity(txt, txt[inst.position], synsets=sim_synsets, majority=True).name()
    ref = mapping.get(raw_ref)

    # for precision, recall, f-measure
    sim_refs[ref].add(i)
    sim_hyps[hyp].add(i)

    # for accuracy
    sim_refs_list.append(ref)
    sim_hyps_list.append(hyp)

print("Lesk similarity:")
print("Acc:", round(accuracy(sim_refs_list, sim_hyps_list), 3))

for cls in sim_hyps.keys():
    p = precision(sim_refs[cls], sim_hyps[cls])
    r = recall(sim_refs[cls], sim_hyps[cls])
    f = f_measure(sim_refs[cls], sim_hyps[cls], alpha=1)

    if(p is None):
      p= 0.0
    if(f is None):
      f = 0.0

    print(cls, "\t\t", round(p,3), "\t\t", round(r,3), "\t\t", round(f,3), "\t\t", len(sim_refs[cls]))

    #print("{:15s}: p={:.3f}; r={:.3f}; f={:.3f}; s={}".format(cls, p, r, f, len(sim_refs[cls])))
